-- BMOD VVIP - Compact Cyberpunk (UI + ESP + Aimbot)
-- Single-file. Menu toggle via button. Compact layout.

-- ===== SETTINGS (DEFAULT) =====
_G.TeamCheck    = true
_G.ESPEnabled   = true
_G.BoxEnabled   = true
_G.NameEnabled  = true
_G.ShowHPBar    = true
_G.ShowLine     = true
_G.AimbotEnabled= true
_G.FOVRadius    = 120
_G.ESPColor     = Color3.fromRGB(0,255,180)
_G.RainbowESP   = false
_G.RainbowSpeed = 0.6
_G.BoxThickness = 1
_G.ESPAlpha     = 1

-- ===== SERVICES =====
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Camera = workspace.CurrentCamera
local LocalPlayer = Players.LocalPlayer

-- ===== DRAWING STORAGE =====
local ESP = {}
local FOV = Drawing.new("Circle")
FOV.NumSides = 100
FOV.Radius = _G.FOVRadius
FOV.Thickness = 1
FOV.Color = Color3.fromRGB(255,30,80)
FOV.Filled = false
FOV.Visible = true
FOV.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)

-- ===== UTIL =====
local function clamp(v,a,b) return math.max(a, math.min(b, v)) end

local function safeRaycast(origin, dir, blacklist)
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = blacklist or {}
    local ok, res = pcall(function() return workspace:Raycast(origin, dir, params) end)
    if not ok then return nil end
    return res
end

local function IsVisible(part)
    if not part or not part.Parent then return false end
    local origin = Camera.CFrame.Position
    local dir = (part.Position - origin)
    if dir.Magnitude <= 0.1 then return true end
    local blacklist = {}
    if LocalPlayer and LocalPlayer.Character then table.insert(blacklist, LocalPlayer.Character) end
    local res = safeRaycast(origin, dir, blacklist)
    if not res then return true end
    return res.Instance and res.Instance:IsDescendantOf(part.Parent)
end

local function hsvColor(h) return Color3.fromHSV((h%1), 0.9, 0.95) end

-- ===== ESP DRAW CREATION / REMOVE =====
local function CreateESP(plr)
    if ESP[plr] then return end
    ESP[plr] = {
        Box = Drawing.new("Square"),
        Name = Drawing.new("Text"),
        HPBG = Drawing.new("Square"),
        HP = Drawing.new("Square"),
        Line = Drawing.new("Line")
    }
    local e = ESP[plr]
    e.Box.Thickness = _G.BoxThickness
    e.Box.Filled = false
    e.Box.Transparency = _G.ESPAlpha
    e.Name.Size = 12
    e.Name.Center = true
    e.Name.Outline = true
    e.HPBG.Filled = true
    e.HPBG.Color = Color3.fromRGB(0,0,0)
    e.HP.Filled = true
    e.Line.Thickness = 1
end

local function RemoveESP(plr)
    if not ESP[plr] then return end
    for _,v in pairs(ESP[plr]) do
        pcall(function() if v and v.Remove then v:Remove() end end)
    end
    ESP[plr] = nil
end

Players.PlayerRemoving:Connect(function(plr) RemoveESP(plr) end)

-- ===== TARGET/BOX CALC =====
local function GetBox(plr)
    if not plr or not plr.Character then return end
    local char = plr.Character
    local head = char:FindFirstChild("Head")
    local hrp = char:FindFirstChild("HumanoidRootPart")
    local humanoid = char:FindFirstChildOfClass("Humanoid")
    if not (head and hrp and humanoid) then return end
    if humanoid.Health <= 0 then return end
    local screenPos, vis = Camera:WorldToViewportPoint(hrp.Position)
    if not vis then return end
    local distance = (Camera.CFrame.Position - hrp.Position).Magnitude
    local scale = clamp(2000 / math.max(distance, 0.1), 3, 650)
    local height = 6 * scale
    local width = 4 * scale
    local topLeft = Vector2.new(screenPos.X - width/2, screenPos.Y - height/2)
    return topLeft, Vector2.new(width, height), humanoid, head, screenPos
end

local function IsValidTarget(plr)
    if not plr then return false end
    if plr == LocalPlayer then return false end
    if _G.TeamCheck and plr.Team == LocalPlayer.Team then return false end
    if not plr.Character then return false end
    return true
end

local function GetClosestHeadInFOV()
    local center = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    local bestHead = nil
    local bestDist = _G.FOVRadius
    for _, plr in ipairs(Players:GetPlayers()) do
        if IsValidTarget(plr) then
            local _, _, humanoid, head = GetBox(plr)
            if head and humanoid and humanoid.Health > 0 then
                local headScr, vis = Camera:WorldToViewportPoint(head.Position)
                if vis then
                    local dist = (Vector2.new(headScr.X, headScr.Y) - center).Magnitude
                    if dist <= _G.FOVRadius and IsVisible(head) then
                        if dist < bestDist then
                            bestDist = dist
                            bestHead = head
                        end
                    end
                end
            end
        end
    end
    return bestHead
end

-- ===== MAIN RENDER LOOP =====
RunService.RenderStepped:Connect(function()
    FOV.Position = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y/2)
    FOV.Radius = _G.FOVRadius

    local anyVisible = false
    local now = tick()

    for _, plr in ipairs(Players:GetPlayers()) do
        if IsValidTarget(plr) and _G.ESPEnabled then
            local boxPos, size, humanoid, head, screenPos = GetBox(plr)
            if boxPos and size then
                if not ESP[plr] then CreateESP(plr) end
                local e = ESP[plr]
                local color = _G.RainbowESP and hsvColor(now * _G.RainbowSpeed) or _G.ESPColor
                e.Box.Color = color
                e.Box.Thickness = _G.BoxThickness
                e.Box.Transparency = _G.ESPAlpha
                e.Name.Color = color
                e.Name.Transparency = _G.ESPAlpha
                e.HP.Transparency = _G.ESPAlpha
                e.HPBG.Transparency = _G.ESPAlpha
                e.Line.Transparency = _G.ESPAlpha

                if _G.BoxEnabled then
                    e.Box.Visible = true
                    e.Box.Position = boxPos
                    e.Box.Size = size
                else
                    e.Box.Visible = false
                end

                if _G.NameEnabled then
                    e.Name.Visible = true
                    e.Name.Position = Vector2.new(boxPos.X + size.X/2, boxPos.Y - 12)
                    e.Name.Text = plr.Name
                else
                    e.Name.Visible = false
                end

                if _G.ShowHPBar then
                    local hpPerc = clamp(humanoid.Health / math.max(humanoid.MaxHealth,1), 0, 1)
                    e.HPBG.Visible = true
                    e.HPBG.Size = Vector2.new(4, size.Y)
                    e.HPBG.Position = Vector2.new(boxPos.X - 6, boxPos.Y)
                    e.HP.Visible = true
                    e.HP.Size = Vector2.new(4, size.Y * hpPerc)
                    e.HP.Position = Vector2.new(boxPos.X - 6, boxPos.Y + size.Y * (1 - hpPerc))
                    if hpPerc <= 0.3 then e.HP.Color = Color3.fromRGB(255,0,0)
                    elseif hpPerc <= 0.6 then e.HP.Color = Color3.fromRGB(255,255,0)
                    else e.HP.Color = Color3.fromRGB(0,255,0) end
                else
                    e.HP.Visible = false
                    e.HPBG.Visible = false
                end

                if _G.ShowLine and screenPos then
                    e.Line.Visible = true
                    e.Line.From = Vector2.new(Camera.ViewportSize.X/2, Camera.ViewportSize.Y)
                    e.Line.To = Vector2.new(screenPos.X, screenPos.Y)
                else
                    e.Line.Visible = false
                end

                local headScr, headVis = Camera:WorldToViewportPoint(head.Position)
                if headVis and (Vector2.new(headScr.X, headScr.Y) - FOV.Position).Magnitude <= _G.FOVRadius and IsVisible(head) then
                    anyVisible = true
                end
            else
                if ESP[plr] then
                    for _,v in pairs(ESP[plr]) do
                        if v and v.Visible ~= nil then v.Visible = false end
                    end
                end
            end
        else
            RemoveESP(plr)
        end
    end

    FOV.Color = anyVisible and Color3.fromRGB(0,255,100) or Color3.fromRGB(255,30,80)

    -- AUTO-AIM (hard lock to visible head in FOV)
    if _G.AimbotEnabled then
        local targetHead = GetClosestHeadInFOV()
        if targetHead and targetHead.Position then
            local aimPos = targetHead.Position
            Camera.CFrame = CFrame.new(Camera.CFrame.Position, aimPos)
        end
    end
end)

-- ===== SIMPLE COMPACT UI (IN-GAME GUI) =====
do
    local parent = nil
    local ok = pcall(function() parent = game:GetService("CoreGui") end)
    if not ok or not parent then parent = LocalPlayer:WaitForChild("PlayerGui") end

    if parent:FindFirstChild("BMOD_VVIP_GUI") then parent.BMOD_VVIP_GUI:Destroy() end

    local gui = Instance.new("ScreenGui")
    gui.Name = "BMOD_VVIP_GUI"
    gui.ResetOnSpawn = false
    gui.Parent = parent

    -- Toggle button (shows/hides menu)
    local toggleBtn = Instance.new("TextButton", gui)
    toggleBtn.Size = UDim2.new(0,120,0,28)
    toggleBtn.Position = UDim2.new(0, 16, 0, 16)
    toggleBtn.BackgroundColor3 = Color3.fromRGB(18,18,20)
    toggleBtn.BorderSizePixel = 0
    toggleBtn.Text = "BMOD VVIP"
    toggleBtn.Font = Enum.Font.GothamBold
    toggleBtn.TextSize = 14
    toggleBtn.TextColor3 = Color3.fromRGB(0,255,160)

    local frame = Instance.new("Frame", gui)
    frame.Size = UDim2.new(0, 300, 0, 220)
    frame.Position = UDim2.new(0, 16, 0, 52)
    frame.BackgroundColor3 = Color3.fromRGB(10,10,12)
    frame.BorderSizePixel = 0
    frame.Visible = false
    local corner = Instance.new("UICorner", frame); corner.CornerRadius = UDim.new(0,8)
    local stroke = Instance.new("UIStroke", frame); stroke.Color = Color3.fromRGB(0,255,160); stroke.Transparency = 0.9; stroke.Thickness = 1

    -- title
    local title = Instance.new("TextLabel", frame)
    title.Size = UDim2.new(1, -12, 0, 28)
    title.Position = UDim2.new(0, 6, 0, 6)
    title.BackgroundTransparency = 1
    title.Font = Enum.Font.GothamBold
    title.TextSize = 14
    title.TextColor3 = Color3.fromRGB(230,230,230)
    title.Text = "「BMOD VVIP」 • CYBERPUNK"

    -- compact grid container
    local content = Instance.new("Frame", frame)
    content.Size = UDim2.new(1, -12, 1, -44)
    content.Position = UDim2.new(0, 6, 0, 38)
    content.BackgroundTransparency = 1
    local grid = Instance.new("UIGridLayout", content)
    grid.CellSize = UDim2.new(0, 140, 0, 28)
    grid.CellPadding = UDim2.new(0, 6)

    -- helper to make small toggle buttons
    local function makeToggle(text, getFunc, setFunc)
        local b = Instance.new("TextButton", content)
        b.Size = UDim2.new(0, 140, 0, 28)
        b.BackgroundColor3 = getFunc() and Color3.fromRGB(0,255,160) or Color3.fromRGB(28,28,34)
        b.BorderSizePixel = 0
        b.Font = Enum.Font.Gotham
        b.TextSize = 13
        b.TextColor3 = Color3.fromRGB(18,18,20)
        b.Text = text
        local corner = Instance.new("UICorner", b); corner.CornerRadius = UDim.new(0,6)
        b.MouseButton1Click:Connect(function()
            setFunc(not getFunc())
            b.BackgroundColor3 = getFunc() and Color3.fromRGB(0,255,160) or Color3.fromRGB(28,28,34)
        end)
        return b
    end

    -- helper small slider (click cycles value)
    local function makeSliderSmall(label, getFunc, setFunc, minV, maxV, step)
        local container = Instance.new("Frame", content)
        container.Size = UDim2.new(0, 140, 0, 28)
        container.BackgroundTransparency = 1

        local lbl = Instance.new("TextLabel", container)
        lbl.Size = UDim2.new(0.6, 0, 1, 0)
        lbl.BackgroundTransparency = 1
        lbl.Font = Enum.Font.Gotham
        lbl.TextSize = 13
        lbl.TextColor3 = Color3.fromRGB(200,200,200)
        lbl.Text = label..": "..tostring(getFunc())

        local btn = Instance.new("TextButton", container)
        btn.Size = UDim2.new(0.4, -4, 1, 0)
        btn.Position = UDim2.new(0.6, 4, 0, 0)
        btn.BackgroundColor3 = Color3.fromRGB(28,28,34)
        btn.BorderSizePixel = 0
        btn.Font = Enum.Font.GothamBold
        btn.TextSize = 13
        btn.TextColor3 = Color3.fromRGB(200,200,200)
        btn.Text = tostring(getFunc())
        local corner = Instance.new("UICorner", btn); corner.CornerRadius = UDim.new(0,6)

        btn.MouseButton1Click:Connect(function()
            local cur = getFunc()
            local s = step or 1
            cur = cur + s
            if cur > maxV then cur = minV end
            setFunc(cur)
            lbl.Text = label..": "..tostring(cur)
            btn.Text = tostring(cur)
        end)

        return container
    end

    -- make toggles (compact)
    makeToggle("ESP", function() return _G.ESPEnabled end, function(v) _G.ESPEnabled = v end)
    makeToggle("Boxes", function() return _G.BoxEnabled end, function(v) _G.BoxEnabled = v end)
    makeToggle("Names", function() return _G.NameEnabled end, function(v) _G.NameEnabled = v end)
    makeToggle("HP Bar", function() return _G.ShowHPBar end, function(v) _G.ShowHPBar = v end)
    makeToggle("Line", function() return _G.ShowLine end, function(v) _G.ShowLine = v end)
    makeToggle("Aimbot", function() return _G.AimbotEnabled end, function(v) _G.AimbotEnabled = v end)
    makeToggle("TeamCheck", function() return _G.TeamCheck end, function(v) _G.TeamCheck = v end)
    makeToggle("Rainbow", function() return _G.RainbowESP end, function(v) _G.RainbowESP = v end)

    -- color presets (no "button" text) - small color boxes row
    local colorFrame = Instance.new("Frame", frame)
    colorFrame.Size = UDim2.new(1, -12, 0, 36)
    colorFrame.Position = UDim2.new(0, 6, 1, -42)
    colorFrame.BackgroundTransparency = 1
    local x = 6
    local presets = {
        Color3.fromRGB(0,255,180),
        Color3.fromRGB(255,90,190),
        Color3.fromRGB(0,255,100),
        Color3.fromRGB(255,220,80),
        Color3.fromRGB(200,0,200),
        Color3.fromRGB(80,140,255)
    }
    for i,c in ipairs(presets) do
        local cb = Instance.new("TextButton", colorFrame)
        cb.Size = UDim2.new(0, 28, 0, 28)
        cb.Position = UDim2.new(0, x, 0, 4)
        cb.BackgroundColor3 = c
        cb.BorderSizePixel = 0
        local bc = Instance.new("UICorner", cb); bc.CornerRadius = UDim.new(0,6)
        cb.Text = ""
        cb.MouseButton1Click:Connect(function()
            _G.ESPColor = c
            _G.RainbowESP = false
        end)
        x = x + 34
    end

    -- small sliders (fov, rainbow speed, thickness, alpha)
    makeSliderSmall("FOV", function() return _G.FOVRadius end, function(v) _G.FOVRadius = v end, 20, 1000, 10)
    makeSliderSmall("RainbowSPD", function() return math.floor(_G.RainbowSpeed*100) end, function(v) _G.RainbowSpeed = clamp(v/100, 0.01, 3) end, 1, 400, 25)
    makeSliderSmall("Thickness", function() return _G.BoxThickness end, function(v) _G.BoxThickness = v end, 1, 8, 1)
    makeSliderSmall("Alpha", function() return math.floor(_G.ESPAlpha*100) end, function(v) _G.ESPAlpha = clamp(v/100, 0, 1) end, 0, 100, 10)

    -- close & toggle
    toggleBtn.MouseButton1Click:Connect(function()
        frame.Visible = not frame.Visible
    end)

    -- small drag for frame
    local dragging, dragStart, startPos = false, nil, nil
    title.InputBegan:Connect(function(inp)
        if inp.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = inp.Position
            startPos = frame.Position
            inp.Changed:Connect(function()
                if inp.UserInputState == Enum.UserInputState.End then dragging = false end
            end)
        end
    end)
    UserInputService.InputChanged:Connect(function(inp)
        if not dragging then return end
        if inp.UserInputType == Enum.UserInputType.MouseMovement or inp.UserInputType == Enum.UserInputType.Touch then
            local delta = inp.Position - dragStart
            frame.Position = UDim2.new(0, startPos.X.Offset + delta.X, 0, startPos.Y.Offset + delta.Y)
        end
    end)
end

-- End of script
